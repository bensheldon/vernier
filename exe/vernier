#!/usr/bin/env ruby

require "optparse"
require "vernier/version"

module Vernier
  module CLI
    def self.run(options)
      banner = <<-END
Usage: vernier run [FLAGS] -- COMMAND

FLAGS:
      END

      OptionParser.new(banner) do |o|
        o.version = Vernier::VERSION

        o.on('--output [FILENAME]', String, "output filename") do |s|
          options[:output] = s
        end
        o.on('--output-dir [DIRECTORY]', String, "output directory (default .)") do |s|
          options[:output_dir] = s
        end
        o.on('--interval [MICROSECONDS]', Integer, "sampling interval (default 500)") do |i|
          options[:interval] = i
        end
        o.on('--allocation-interval [ALLOCATIONS]', Integer, "allocation sampling interval (default 0 disabled)") do |i|
          options[:allocation_interval] = i
        end
        o.on('--signal [NAME]', String, "specify a signal to start and stop the profiler") do |s|
          options[:signal] = s
        end
        o.on('--start-paused', "don't automatically start the profiler") do
          options[:start_paused] = true
        end
        o.on('--hooks [HOOKS]', String, "enable instrumentation hooks, currently supported: rails") do |s|
          options[:hooks] = s
        end
      end
    end

    def self.view(options)
      banner = <<-END
Usage: vernier view [FLAGS] -- FILENAME

FLAGS:
      END

      OptionParser.new(banner) do |o|
        o.on('--top [COUNT]', Integer, "number of frames to show (default 20)") do |i|
          options[:top] = i
        end
      end
    end

    class SamplesByLocation
      attr_accessor :self, :total
      def initialize
        @self = @total = 0
      end

      def +(other)
        ret = SamplesByLocation.new
        ret.self = @self + other.self
        ret.total = @total + other.total
        ret
      end
    end

    def self.inverted_tree(top, file)
      # Print the inverted tree from a Vernier profile
      require "json"

      is_gzip = File.binread(file, 2) == "\x1F\x8B".b # check for gzip header

      json = if is_gzip
        require "zlib"
        Zlib::GzipReader.open(file) { |gz| gz.read }
      else
        File.read file
      end

      info = JSON.load json

      main = info["threads"].find { |thread| thread["isMainThread"] }

      weight_by_frame = Hash.new(0)

      stack_frames = main["stackTable"]["frame"]
      frame_func_table = main["frameTable"]["func"]
      func_name_table = main["funcTable"]["name"]
      string_array = main["stringArray"]

      main["samples"]["stack"].zip(main["samples"]["weight"]).each do |stack, weight|
        top_frame_index = stack_frames[stack]
        func_index = frame_func_table[top_frame_index]
        string_index = func_name_table[func_index]
        str = string_array[string_index]
        weight_by_frame[str] += weight
      end

      total = weight_by_frame.values.inject :+

      header = ["Samples", "%", ""]
      widths = header.map(&:bytesize)

      columns = weight_by_frame.sort_by { |k,v| v }.reverse.first(top).map { |k,v|
        entry = [v.to_s, ((v / total.to_f) * 100).round(1).to_s, k]
        entry.each_with_index { |str, i| widths[i] = str.bytesize if widths[i] < str.bytesize }
        entry
      }

      print_separator widths
      print_row header, widths
      print_separator widths
      columns.each { print_row(_1, widths) }
      print_separator widths

      self_samples_by_frame = Hash.new do |h, k|
        h[k] = SamplesByLocation.new
      end

      stack_parents = main["stackTable"]["prefix"]
      main["samples"]["stack"].zip(main["samples"]["weight"]).each do |stack_idx, weight|
        # self time
        top_frame_index = stack_frames[stack_idx]
        self_samples_by_frame[top_frame_index].self += weight

        # total time
        while stack_idx
          frame_idx = stack_frames[stack_idx]
          self_samples_by_frame[frame_idx].total += weight
          stack_idx = stack_parents[stack_idx]
        end
      end

      samples_by_file = Hash.new do |h, k|
        h[k] = Hash.new do |h2, k2|
          h2[k2] = SamplesByLocation.new
        end
      end

      frame_lines = main["frameTable"]["line"]
      func_filenames = main["funcTable"]["fileName"]
      self_samples_by_frame.each do |frame, samples|
        line = frame_lines[frame]
        func_index = frame_func_table[frame]
        filename = func_filenames[func_index]
        #string_index = func_name_table[func_index]

        samples_by_file[filename][line] += samples
      end

      samples_by_file.transform_keys! { string_array[_1] }

      #FIXME
      print_file("examples/gvl_sleep.rb", samples_by_file)
    end

    def self.print_file(filename, all_samples)
      samples = all_samples[filename]

      output = +""
      # file_name, lines, file_wall, file_cpu, file_idle, file_sort
      output << sprintf("TOTAL |  SELF | SOURCE\n")
      File.readlines(filename).each_with_index do |line, i|
        lineno = i + 1
        #wall, cpu, calls = lines[i + 1]
        wall, cpu, calls = 0,0,0
        calls = samples[lineno]

        if calls && calls.total > 0
          #output << sprintf("% 8.1fms (% 5d) | %s", wall, calls, line)
          output << sprintf("% 5d | % 5d | %s", calls.total, calls.self, line)
        else
          output << sprintf("      |       | %s", line)
        end
      end
      puts output
    end

    def self.print_row(list, widths)
      puts("|" + list.map.with_index { |str, i| " " + str.ljust(widths[i] + 1) }.join("|") + "|")
    end

    def self.print_separator(widths)
      puts("+" + widths.map { |i| "-" * (i + 2) }.join("+") + "+")
    end
  end
end

options = {}
run = Vernier::CLI.run(options)
view = Vernier::CLI.view(options)

case ARGV.shift
when "run"
  run.parse!
  run.abort(run.help) if ARGV.empty?

  env = {}
  options.each do |k, v|
    env["VERNIER_#{k.to_s.upcase}"] = v.to_s
  end
  vernier_path = File.expand_path('../lib', __dir__)
  env['RUBYOPT'] = "-I #{vernier_path} -r vernier/autorun #{ENV['RUBYOPT']}"

  Kernel.exec(env, *ARGV)
when "view"
  view.parse!
  view.abort(view.help) if ARGV.empty?
  Vernier::CLI.inverted_tree(options[:top] || 20, ARGV.shift)
else
  run.abort(run.help + "\n" + view.help)
end
